---
title: "How to estimate local recombination rates with the Marey map method"
output: rmarkdown::html_vignette
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{RecombinationMap}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(ggplot2)
```

The package is loaded with the following command.

```{r setup}
library(EasyMareyMap)
```


# Create a MareyMap object

You can import the example dataset based on linkage maps for the five chromosomes of the plant *Arabidopsis thaliana* [@serin_construction_2017].


The datasets for the 'EasyMareyMap' package are formatted according to the specifications of input files of the MareyMap package [@rezvoy_mareymap:_2007]. It is a tab-separated file with five columns named 'set', 'map, 'mkr', 'phys', 'gen', 'vld'. Genomic coordinates are in basepairs (bp) and genetic distances in cM.

You can create a `MareyMap` object. It must contain a single map (i.e. one chromosome).


```{r importMap}
m = read.table("../inst/extdata/Arabidopsis_thaliana.txt",
               header = T,
               sep = "\t")
# The marey map is imported into a 'mareyMap' object
marey = mareyMap(m, chromosome = '1')
# names of slots in the 'mareyMap' object
names(marey)
# Column names of the input Marey map
names(marey$mareyMap)

head(marey)
```



There is also a method to display a `summary` of a `mareyMap` object.

```{r summary}
summary(marey)
```


# Maniupulate a Marey map


Coorection for outliers. Removing outliers.

Here is the command to do outlier selection in a visual mode. You just need to draw a region around markers to remove. Left-click to place points of the polygon, then right-click to close the region and return to the script. All markers selected are automatically marked as removed (`vld =  FALSE`).

```
marey = outlierSelection(marey, "1")
```

<!-- TODO Add a photo of mkr selection -->


There is a method to `plot` the Marey map of a `mareyMap` object. Markers kept for further interpolation are in blue. Markers discarded are in red. Markers can be masked (unmasked) in genomi intervals with the 'mask.interval' function ('unmask.interval' rspectively).


```{r plot, message=FALSE, warning=FALSE, echo=FALSE, fig.height = 4, fig.width = 6, fig.align="center", fig.cap = "Marey maps of chromosome 1 in *Arabidopsis thaliana*. Invalid markers are shown in red."}
#Arbitrary set a few un-valid markers in red
interv = data.frame(start = marey$mareyMap$phys[20], end = marey$mareyMap$phys[40])
marey = mask.interval(marey, interv)

plot(marey)

marey = unmask.interval(marey, interv)
```





Error correction.
Flip an interval or an entire chromosome.


```{r plotFlip, message=FALSE, warning=FALSE, echo=FALSE, fig.height = 4, fig.width = 6, fig.align="center", fig.cap = "Flipping a genomic interval."}
plot(marey)
interv = data.frame(start = c(1, 25000000), end = c(10000000, 50000000))
tmp = flip.interval(marey, intervals = interv)

plot(tmp)
```


```{r plotFlipChromosome, message=FALSE, warning=FALSE, echo=FALSE, fig.height = 4, fig.width = 6, fig.align="center", fig.cap = "Flipping the entire chromosome"}
wholechromosome = data.frame(start = c(1), end = c(marey$chromosomeLength))
tmp = flip.interval(marey, intervals = wholechromosome)

plot(tmp)
```


Mask a region




# Estimate a recombination map

All the procedure to estimate the recombination map is done with the `recombinationMap()` function which returns a `mareyMap` object with an estimated recombination map. A description of the method is available in Brazier and Glémin [@brazierDiversityDeterminantsRecombination2022].


```{r estimateMap}
res = recombinationMap(marey, method = "loess")
```


```{r plotInterpolation, message=FALSE, warning=FALSE, echo=FALSE, fig.height = 4, fig.width = 6, fig.align="center", fig.cap = "Marey maps of five chromosomes in *Arabidopsis thaliana* with the Marey interpolation line and a 95% C.I. (invalid markers are shown in red)."}
plot(res)
```



```{r headMap, echo=TRUE, message=FALSE}
head(res$recMap)
```


```{r summaryResults, echo=TRUE, message=FALSE}
summary(res)
```

Finally, the recombination landscape can be plotted with the `recombinationPlot()` function.

```{r plotMap, message=FALSE, warning=FALSE, echo=FALSE, fig.height = 4, fig.width = 8, fig.align="center", fig.cap = "Recombination landscape of *Arabidopsis thaliana*. The gray area is the 95% confidence interval around the mean estimate."}
plot_recombination(res)
```



# Quality control and map validation


Compare loess and smooth splines.

First fit a loess and print the goodness of fit.

```{r fitLoess, echo=TRUE, message=FALSE}
res_loess = recombinationMap(marey, method = "loess", verbose = FALSE)
summary.mareyMap(res_loess)
```


Then fit a spline and print the goodness of fit again.

```{r fitSpline, echo=TRUE, message=FALSE}
res_spline = recombinationMap(marey, method = "spline", verbose = FALSE)
summary(res_spline)
```


In this case, the two interpolation methods are similarly good.


```{r fitFigure, echo=TRUE, message=FALSE, fig.height = 4, fig.width = 6, fig.align="center", fig.cap = "Goodness of fit of the Marey interpolated function, either with Loess regression or smooth Splines interpolation."}
df_loess = data.frame(method = "loess",
                     y = res_loess$mareyMap$gen,
                     fitted = res_loess$fitted,
                     residuals = res_loess$residuals)
df_spline = data.frame(method = "spline",
                     y = res_spline$mareyMap$gen,
                     fitted = res_spline$fitted,
                     residuals = res_spline$residuals) 
df_compare = rbind(df_loess, df_spline)

p1 = ggplot(df_compare, aes(x = y, y = fitted)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE) +
  facet_wrap(~ method) +
  theme_bw()
p1

p2 = ggplot(df_compare, aes(x = residuals, y = fitted)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE) +
  facet_wrap(~ method) +
  theme_bw()
p2
```


# Custom or pointwise physical positions

By default, a grid of windows of constant size is mapped along the chromosome. But you can also provide a data frame of custom start/end positions to estimate the recombination rate within.


```{r customWindows}
pos = data.frame(start = seq(20000, 40000000, by = 40000),
                 end = seq(20000, 40000000, by = 40000) + 20000)
res = recombinationMap(res, method = "loess", windows = pos, verbose = FALSE)
```

This custom positions can represent any genomic feature (e.g. gene, exon) or marker (e.g. SNP) for which you want to estimate the average recombination rate. However keep in mind that interpolation is at a large scale (i.e. does not detect fine scale variations of recombination rates) and close markers can have exactly or very similar values due to the large scale smoothing.



```{r customWindows2}
genes = data.frame(chromosome = "4",
                   start = c(60000, 99000, 123000, 267400, 500000),
                   end = c(65000, 99500, 1234000, 267401, 500001))
pos = data.frame(start = genes$start,
                 end = genes$end)
res = recombinationMap(res, method = "loess", windows = pos, verbose = FALSE)

res$windows
res$recMap
```







# Interpolate new genetic positions

You may want to change your physical map and interpolate the genetic distances for your new set of markers. It is possible to interpolate these new positions with the `predict` function corresponding to the interpolation method (e.g. `predict.loess` for the `fit.loess` method). I implemented a generic `predictGeneticMap` function to do the job.


It is recommended to use the smoothing parameter previously estimated with the automatic calibration procedure.


```{r predictGeneticMap}
phys = res$mareyMap$phys
gen = res$mareyMap$gen
# Re-map on a regular grid of evenly spaced markers
new = seq(50000, 30450000, by = 1000000)
smoothPar = res$smoothingParam
newMap = predictGeneticMap(phys, gen, new, method = "loess", smoothing = smoothPar)

newMap
```


```{r newGeneticMap, message=FALSE, warning=FALSE, echo=FALSE, fig.height = 4, fig.width = 6, fig.align="center", fig.cap = "New positions on chromosome 1, with the confidence interval (+- 1.96*se)."}
newMap$phys = new
newMap = as.data.frame(newMap)

ggplot2::ggplot(data = newMap, aes(x = phys/10^6, y = newGen)) +
  geom_point(alpha = 0.4) +
  labs(x = "Genomic position (Mb)", y = "Genetic distance (cM)") +
  geom_errorbar(aes(ymin = newGen - 1.96*se, ymax = newGen + 1.96*se)) +
  theme(axis.line = element_line(),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            panel.border = element_blank(),
            panel.background = element_blank(),
            plot.title = element_text(color="black", face="bold.italic",hjust = 0.5),
            plot.subtitle = element_text(color="black",hjust = 0.5),
            axis.title.x = element_text(color="black"),
            axis.title.y = element_text(color="black"),
            axis.text=element_text(colour="black"),
            legend.position = "right")
```


# Analysing and comparing Marey landscapes


## Chromosome-wide statistics


These statistics, estimated on the whole chromosomes, can be used to compare chromosomes, populations or species.

Intra-chromosomal genetic shuffling (Veller et al. 2019).

```{r veller}
genome_size = 119050000
veller(res, genomeSize = genome_size, mappingFunction = "none")
veller(res, genomeSize = genome_size, mappingFunction = "haldane")
veller(res, genomeSize = genome_size, mappingFunction = "kosambi")
```


The periphery-bias ratio, as computed in Brazier and Glémin (2022). 

```{r peripherybias}
peripherybias(res, proportion_periphery = 0.1,  chromosome_arm = "random")
peripherybias(res, proportion_periphery = 0.1,  chromosome_arm = "left")
peripherybias(res, proportion_periphery = 0.1,  chromosome_arm = "right")
peripherybias(res, proportion_periphery = 0.1,  chromosome_arm = "both")
```



The coefficient of variation.


```{r coefficient_variation}
coefficientVariation(res)
```


The Gini index.


```{r gini}
gini(res)
```


The Lorenz curve.

```{r lorenz}
lore = lorenz(res)
diagonal = data.frame(x = seq(0, 1, by = 0.01),
                      y = seq(0, 1, by = 0.01))
ggplot(data = lore, aes(x = relativePhys, y = relativeGen)) +
  geom_line() +
  geom_line(data = diagonal, aes(x = x, y = y), color = "Grey") +
  xlim(0, 1) +
  ylim(0, 1) +
  xlab("Proportion of genomic distance") +
  ylab("Proportion of genetic distance") +
  theme_bw()
```





## Compare multiple maps mapped on the same chromosome

Different genetic map, same physical map
Compare chromosome landscapes between sexes, populations, with physical positions mapped on the same reference genome.

e.g. heterochiasmy, compare males and females

Figures ggplot


Quantitative measures





## Same genetic map, but different physical positions


Transform physical positions (e.g. gene distances)
Interpolation/predict new positions


Homeolog chromosomes in polyploids



Relative distances


Figures ggplot


Quantitative measures




## Comparing blocks and intervals


SVs
Synteny in closed species
Homeolog regions in polyploids



Quantitative measures
Whole chromosomes
Blocks/interval
...
Random resampling?







# References
